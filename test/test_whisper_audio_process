from libs.whisper_audio_processor import WhisperAudioProcessor
import time
import threading
import uuid
import signal
import sys
from models.batch_task import Task, BatchTask

def batch_completed_hook(batch: BatchTask):
    """Example hook function called when a batch is completed."""
    print(f"\nBatch {batch.batch_id} completed with status: {batch.status}")
    print(f"Progress: {batch.progress:.1f}% ({batch.completed_tasks}/{batch.total_tasks})")
    print(f"Success rate: {batch.success_rate:.1f}%")
    
    for task in batch.tasks:
        if task.status.value == "completed":
            # Print first few words of transcription if available
            if task.output and len(task.output) > 0 and 'text' in task.output[0]:
                preview = task.output[0]['text'][:100] + "..." if len(task.output[0]['text']) > 100 else task.output[0]['text']
                print(f"  Task {task.task_id}: {task.status.value} - '{preview}'")
            else:
                print(f"  Task {task.task_id}: {task.status.value}")
        else:
            print(f"  Task {task.task_id}: {task.status.value}")
            if task.error:
                print(f"    Error: {task.error}")
        
        # Show processing time if available
        if task.processing_time:
            print(f"    Processing time: {task.processing_time:.2f}s")

def auto_batch_adder(processor: WhisperAudioProcessor, interval: int = 10, stop_event: threading.Event = None):
    """Automatically adds a new batch every `interval` seconds."""
    batch_count = 0
    
    while not (stop_event and stop_event.is_set()):
        try:
            batch_count += 1
            batch_id = f"auto_batch_{batch_count:03}_{uuid.uuid4().hex[:4]}"
            tasks = []
            
            # Example: 2 tasks per batch
            for i in range(1, 3):
                task_id = f"{batch_id}_task_{i:03}"
                tasks.append(Task(
                    task_id=task_id,
                    file_path="./test/test1.wav",  # Replace with actual audio files
                    task="transcribe",
                    lang="en",
                    prompt="This is a test audio transcription."  # Optional prompt
                ))
            
            batch = BatchTask(
                batch_id=batch_id, 
                start_time=time.time(), 
                tasks=tasks
            )
            
            if processor.add_batch(batch):
                print(f"‚úì Batch {batch_id} added successfully")
            else:
                print(f"‚úó Failed to add batch {batch_id}")
            
            # Wait for the interval or until stop event is set
            for _ in range(interval * 10):  # Check every 0.1 seconds
                if stop_event and stop_event.is_set():
                    break
                time.sleep(0.1)
                
        except Exception as e:
            print(f"Error in auto batch adder: {e}")
            time.sleep(1)
    
    print("Auto batch adder stopped")

def print_stats(processor: WhisperAudioProcessor):
    """Print comprehensive processor statistics."""
    stats = processor.get_stats()
    
    print("\n" + "="*60)
    print("PROCESSOR STATISTICS")
    print("="*60)
    print(f"Status: {'üü¢ Running' if stats.is_running else 'üî¥ Stopped'}")
    print(f"Uptime: {stats.uptime:.1f}s")
    print(f"Processed Batches: {stats.processed_batches}")
    print(f"Failed Batches: {stats.failed_batches}")
    print(f"Input Queue Size: {stats.input_queue_size}")
    print(f"Output Queue Size: {stats.output_queue_size}")
    
    print("\nPERFORMANCE METRICS")
    print("-" * 30)
    print(f"Total Processed Tasks: {stats.performance_metrics.total_processed}")
    print(f"Total Failed Tasks: {stats.performance_metrics.total_failed}")
    print(f"Is Busy: {'üîÑ Yes' if stats.performance_metrics.is_busy else '‚è∏Ô∏è  No'}")
    print(f"Avg Processing Time: {stats.performance_metrics.avg_processing_time:.2f}s")
    print(f"Throughput: {stats.performance_metrics.throughput_per_hour:.1f} batches/hour")
    print("="*60)

def signal_handler(signum, frame, processor: WhisperAudioProcessor, stop_event: threading.Event):
    """Handle shutdown signals gracefully."""
    print(f"\nReceived signal {signum}. Shutting down gracefully...")
    stop_event.set()
    
    # Print final stats
    print_stats(processor)
    
    # Stop the processor
    print("Stopping processor...")
    if processor.stop(timeout=15.0):
        print("‚úì Processor stopped successfully")
    else:
        print("‚ö† Processor did not stop cleanly")
    
    sys.exit(0)

if __name__ == "__main__":
    # Create processor manually (no context manager)
    processor = WhisperAudioProcessor(batch_completed_hook)
    stop_event = threading.Event()
    
    # Setup signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, lambda s, f: signal_handler(s, f, processor, stop_event))
    signal.signal(signal.SIGTERM, lambda s, f: signal_handler(s, f, processor, stop_event))
    
    try:
        # Start the processor manually
        print("Starting WhisperAudioProcessor...")
        if not processor.start():
            print("‚ùå Failed to start processor")
            sys.exit(1)
        
        print("‚úÖ Processor started successfully")
        
        # Start auto batch adder in a separate thread
        batch_thread = threading.Thread(
            target=auto_batch_adder, 
            args=(processor, 10, stop_event), 
            daemon=True
        )
        batch_thread.start()
        print("‚úÖ Auto batch adder started")
        
        # Monitor processing with enhanced stats display
        print("\nStarting monitoring... (Press Ctrl+C to stop)")
        last_stats_time = 0
        
        while not stop_event.is_set():
            current_time = time.time()
            
            # Print detailed stats every 30 seconds
            if current_time - last_stats_time >= 30:
                print_stats(processor)
                last_stats_time = current_time
            else:
                # Print basic status every second
                stats = processor.get_stats()
                status_indicator = "üîÑ" if stats.performance_metrics.is_busy else "‚è∏Ô∏è"
                queue_info = f"In:{stats.input_queue_size} Out:{stats.output_queue_size}"
                print(f"[{time.strftime('%H:%M:%S')}] {status_indicator} {queue_info} "
                      f"Processed: {stats.processed_batches} Failed: {stats.failed_batches}")
            
            time.sleep(1)
            
    except KeyboardInterrupt:
        signal_handler(signal.SIGINT, None, processor, stop_event)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        stop_event.set()
        
        # Try to stop processor cleanly
        try:
            processor.stop(timeout=10.0)
        except:
            pass
        
        sys.exit(1)